import React, { useState, useEffect, useRef } from 'react';
import { Handle, Position } from 'reactflow';
import '../../css/Nodes.css';
import { MessageSquare, Settings, RefreshCw, CheckCircle, AlertCircle } from 'lucide-react';

const AIChatNode = ({ data, isConnectable }) => {
  const [systemPrompt, setSystemPrompt] = useState(data.systemPrompt || 'You are a helpful AI assistant.');
  const [userPrompt, setUserPrompt] = useState(data.userPrompt || '');
  const [isEditingSystem, setIsEditingSystem] = useState(false);
  const [isGenerating, setIsGenerating] = useState(false);
  const [chatHistory, setChatHistory] = useState(data.chatHistory || []);
  const [nodeState, setNodeState] = useState('idle'); // idle, processing, complete, error
  const systemPromptRef = useRef(null);
  
  // Update data when state changes
  useEffect(() => {
    if (data.onChange) {
      data.onChange({ 
        systemPrompt, 
        userPrompt, 
        chatHistory,
        isGenerating
      });
    }
  }, [systemPrompt, userPrompt, chatHistory, isGenerating, data]);
  
  // Focus system prompt input when editing
  useEffect(() => {
    if (isEditingSystem && systemPromptRef.current) {
      systemPromptRef.current.focus();
    }
  }, [isEditingSystem]);
  
  // Update state based on flow execution
  useEffect(() => {
    if (data.isExecuting) {
      setNodeState('processing');
      setIsGenerating(true);
    } else if (data.executionComplete) {
      setNodeState('complete');
      setIsGenerating(false);
    } else if (data.executionError) {
      setNodeState('error');
      setIsGenerating(false);
    } else if (!data.isInExecutionPath) {
      setNodeState('idle');
      setIsGenerating(false);
    }
  }, [data.isExecuting, data.executionComplete, data.executionError, data.isInExecutionPath]);
  
  const handleSystemPromptChange = (e) => {
    setSystemPrompt(e.target.value);
  };
  
  const handleUserPromptChange = (e) => {
    setUserPrompt(e.target.value);
  };
  
  const toggleSystemPromptEdit = () => {
    setIsEditingSystem(!isEditingSystem);
  };
  
  // Generate AI response - can be called directly or as part of the flow
  const generateAIResponse = async (inputPrompt = userPrompt) => {
    if (!inputPrompt.trim()) return null;
    
    setIsGenerating(true);
    setNodeState('processing');
    
    // Add user message to chat history
    const updatedHistory = [
      ...chatHistory,
      { role: 'user', content: inputPrompt }
    ];
    setChatHistory(updatedHistory);
    
    try {
      // In a real implementation, this would call an API
      // For now, we'll simulate a response
      return new Promise((resolve) => {
        setTimeout(() => {
          const aiResponse = `This is a simulated response to: "${inputPrompt}"\n\nIn a real implementation, this would be generated by an AI API using the system prompt: "${systemPrompt}"`;
          
          // Add AI response to chat history
          setChatHistory([
            ...updatedHistory,
            { role: 'assistant', content: aiResponse }
          ]);
          
          // Update the output node if connected
          if (data.onOutputChange) {
            data.onOutputChange(aiResponse);
          }
          
          setIsGenerating(false);
          setNodeState('complete');
          
          // Reset to idle after a delay
          setTimeout(() => {
            setNodeState('idle');
          }, 2000);
          
          resolve(aiResponse);
        }, 1500);
      });
    } catch (error) {
      console.error('Error generating response:', error);
      setIsGenerating(false);
      setNodeState('error');
      return null;
    }
  };
  
  const handleResetChat = () => {
    setChatHistory([]);
    setUserPrompt('');
    if (data.onOutputChange) {
      data.onOutputChange('');
    }
  };
  
  // Handle flow execution when this node is triggered
  useEffect(() => {
    if (data.registerNodeForFlow) {
      // Register this node for flow execution
      data.registerNodeForFlow(data.id, async (inputData) => {
        // If receiving input from a previous node, use that as prompt
        const prompt = inputData?.prompt || userPrompt;
        const response = await generateAIResponse(prompt);
        return { response };
      });
    }
  }, [data, userPrompt]);

  return (
    <div className={`ai-chat-node node-container ${data.isInExecutionPath ? 'in-path' : ''} ${nodeState}`}>
      <Handle
        type="target"
        position={Position.Top}
        isConnectable={isConnectable}
        style={{ background: '#7952b3' }}
      />
      <div className="node-header">
        <MessageSquare size={16} />
        <div className="node-title">AI Chat</div>
        <div className="node-actions">
          <button 
            className="node-action-btn" 
            onClick={toggleSystemPromptEdit}
            title="Edit system prompt"
          >
            <Settings size={14} />
          </button>
          <button 
            className="node-action-btn" 
            onClick={handleResetChat}
            title="Reset chat"
          >
            <RefreshCw size={14} />
          </button>
        </div>
      </div>
      <div className="node-content">
        {isEditingSystem ? (
          <div className="system-prompt-editor">
            <textarea
              ref={systemPromptRef}
              value={systemPrompt}
              onChange={handleSystemPromptChange}
              placeholder="Enter system prompt..."
              className="system-prompt-input"
            />
            <button 
              className="node-action-btn"
              onClick={toggleSystemPromptEdit}
            >
              Done
            </button>
          </div>
        ) : (
          <div className="system-prompt-display">
            <div className="system-prompt-label">System Prompt:</div>
            <div className="system-prompt-text">{systemPrompt}</div>
          </div>
        )}
        
        <div className="chat-input-container">
          <textarea
            value={userPrompt}
            onChange={handleUserPromptChange}
            placeholder="Type your message here..."
            className="user-prompt-input"
            disabled={isGenerating}
          />
        </div>
        
        <div className="flow-info">
          {nodeState === 'processing' ? (
            <div className="generating-indicator">
              <RefreshCw size={14} className="spinning" /> Generating...
            </div>
          ) : nodeState === 'complete' ? (
            <div className="complete-indicator">
              <CheckCircle size={14} /> Response generated
            </div>
          ) : nodeState === 'error' ? (
            <div className="error-indicator">
              <AlertCircle size={14} /> Error generating response
            </div>
          ) : (
            <div className="flow-instruction">
              This node will process when the flow is executed.
            </div>
          )}
        </div>
        
        {chatHistory.length > 0 && (
          <div className="chat-history">
            {chatHistory.map((message, index) => (
              <div 
                key={index} 
                className={`chat-message ${message.role === 'user' ? 'user-message' : 'ai-message'}`}
              >
                {message.content}
              </div>
            ))}
          </div>
        )}
      </div>
      <Handle
        type="source"
        position={Position.Bottom}
        isConnectable={isConnectable}
        style={{ background: '#7952b3' }}
      />
    </div>
  );
};

export default AIChatNode;